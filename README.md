# Бинарный транслятор RXcc

Данный проект представляет из себя аналог компилятора, транслирующий код, написанный на моем языке программирования (подробнее в проекте [Programming_language](https://github.com/Raptor-X102/Programming-language)) в [мой ассемблер](https://github.com/Raptor-X102/Processor), в nasm и сразу в x86-64.

## Формат и флаги компиляции

| Флаг 	| Описание                                                                                                  	|
|------	|-----------------------------------------------------------------------------------------------------------	|
| -s   	| Source flag, отвечает за исходный файл с кодом                                                            	|
| -a   	| Asm flag, далее файл, в который будет записан <br>скомпилированный в nasm код                                 	|
| -d   	| Debug flag, далее .dot файл для работы с graphviz <br>для отладки в виде дерева                               	|
| -Ma  	| My asm flag, далее файл в который будет записан <br>скомпилированный в мой ассемблер код                      	|
| -o   	| Exe flag, далее имя выходного файла. Для корректной работы <br>без расширения либо с расширениями exe или cpp 	|

Пример вызова
```
RXcc.exe -s Solve_quad_eq.txt -a First_exe.asm -d Lang_debug.dot -o First_exe -Ma My_asm1.asm
```

## Правила для корректного использования

Обязательно должна быть папка In_out_modules. Это ключевой файл для генерации exe-файла. Также необходим компилятор g++ 14.2.0 (возможно, даже необходимо иметь реализацию Rev3, Built by MSYS2 project, поскольку не гарантируется, что скомпилированный код на других реализациях в некоторых случаях будет совпадать). В противном случае работоспособность не гарантируется.

## Особенности реализации

Для того, чтобы компилировать код сразу в x86-64, необходимо генерировать exe-файл. Проект писался на windows 11, поэтому разобраться в том, как генерировать пролог и эпилог файла не было возможности. Для этого пришлось бы разбираться в том, как работает CRT инициализация/деинициализация, менять все относительные адреса после генерации и так далее. Поэтому было принято решение облегчить задачу, генерируя exe-файл нужного размера спомощью компилятора g++. Об этом далее.
Основной файлы, генерирующий x86-64 код - Backend_funcs_x64.cpp и Backend_funcs_x64.h. Запись инструкций происходит в динамический массив (папка Dynamic_array) с помощью различный макросов. После того, как весь код записан, генерируется cpp-файл In_out_mod.cpp на основе исходного файла In_out_modules.cpp. В него записывается количество ассемблерных вставок иструкции nop, равное размеру скомпилированного кода. Далее этот файл компилируется в исполняемый файл. В него вставляется скомпилированный код и получается на выходе exe-файл вашего кода, написанного на моем языке.

### Более тонкие нюансы исполнения

1. Все вычисления реализованы на стеке.
2. Все операции с числами с плавающей точкой.
3. Из-за того, что инструкция comisd (сравнивание двух 64-битных чисел с плавающей точкой) работает как беззнаковое, то все условные jump-инструкции работают в пределах 128 инструкций. Поэтому для работы с более длинным кодом, реализована промежуточная безуслованая jmp инструкция, работающая уже со смещениями на адресаию в 32 бита.
4. Ограничение по размеру кода в скомпилированном виде - 2^16 инструкций. Это связано с генерацией exe-файла. Не проблема увеличить этот размер, но для корретной работы в данной версии реализован этот размер.
5. Внутреннее соглашение о вызове:
Все параметры функции передаются через стек. Push происходит начиная с последнего параметра. Далее после call заносится адрес возврата. Пролог функции начинатеся с push rbp. После этого в стек заносятся локальные переменные.
Наглядное представление стека
стековый фрейм вызывающей функции

```
параметр n
параметр n-1
...
параметр 1
адрес возврата
rbp
локальная переменная 1
локальная переменная 2
...
локальная переменная k
```

Такое соглашение о вызовах было принято в связи с тем, что проще всего передавать параметры через стек. В windows calling conventions принято выделять еще теневой стек, дополнительный 32 байта либо под первые 4 аргумента, которые передаются через регистры, либо для отладки. Поэтому было принято решение оптимизировать это место. Также удобно разделять локальные переменные и передваемые параметры.
6. Перед каждым вызовом функции для выравнивания стека на 16 (для корректной работы с xmm-регистрами) вызывается 1 из двух вспомогательных функций check_alignment (even, odd) в зависимости от числа параметров у вызываемой функции.
7. Расположение функций разработчика относительно main не важно: пользователь может вставлять их как до, так и после. Это реальизовано с помощью самой первой инструкции - jmp main.
